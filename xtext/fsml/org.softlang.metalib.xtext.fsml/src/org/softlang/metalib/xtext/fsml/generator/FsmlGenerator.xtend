/*
 * generated by Xtext 2.10.0
 */
package org.softlang.metalib.xtext.fsml.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.softlang.metalib.xtext.fsml.fsml.FSMTransition
import org.softlang.metalib.xtext.fsml.fsml.FSMState
import org.softlang.metalib.xtext.fsml.fsml.FSM

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FsmlGenerator extends AbstractGenerator {

	/**
	 * Utility, gets the file name without the extension
	 */
	def getFileName(String name) {
		val l = name.lastIndexOf('.');

		if (l >= 0) {
			return name.substring(0, l);
		} else {
			return name;
		}
	}

	/**
	 * Gets an appropriate package name for the resource
	 */
	def getPackageName(Resource resource) {
		val result = new StringBuilder;

		val uri = resource.URI;
		for (i : 3 ..< uri.segmentCount - 1) {
			result.append(uri.segment(i).toFirstLower)
			result.append('.')
		}

		result.append(uri.lastSegment.toFirstLower.fileName);

		return result.toString;
	}

	/**
	 * Gets an appropriate package file path for the resource
	 */
	def getPackagePath(Resource resource) {
		val result = new StringBuilder;

		val uri = resource.URI;
		for (i : 3 ..< uri.segmentCount - 1) {
			result.append(uri.segment(i).toFirstLower)
			result.append('/')
		}

		result.append(uri.lastSegment.toFirstLower.fileName);

		return result.toString;
	}

	def getContainingState(FSMTransition t) {
		return t.eContainer as FSMState;
	}

	def getDestinationState(FSMTransition t) {
		return if(t.target == null) t.containingState else t.target;
	}

	def getGraphLabel(FSMTransition t) {
		return if(t.action == null) t.input else "'" + t.input + "/" + t.action + "'";
	}

	override doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val packageName = resource.packageName;
		val packagePath = resource.packagePath;

		for (FSM fsm : resource.allContents.filter(typeof(FSM)).toIterable) {

			// Precalculate values
			val states = fsm.states.map[s|s.name].toSet;
			val initial = fsm.states.findFirst[s|s.initial].name;
			val inputs = fsm.states.map[s|s.transitions.map[t|t.input]].flatten.toSet;
			val actions = fsm.states.map[s|s.transitions.filter[t|t.action != null].map[t|t.action]].flatten.toSet;

			// Find all states and write down their names
			fsa.generateFile(packagePath + '/State.java', '''
			package «packageName»;
			
			public enum State
			{
				«FOR x : states SEPARATOR ', '»«x»«ENDFOR»
			}''');

			// Find all inputs and write down the distinct names
			fsa.generateFile(packagePath + '/Input.java', '''
			package «packageName»;
			
			public enum Input
			{
				«FOR x : inputs SEPARATOR ', '»«x»«ENDFOR»
			}''');

			// Find all actions and write down the distinct names
			fsa.generateFile(packagePath + '/Action.java', '''
			package «packageName»;
			
			public enum Action
			{
				«FOR x : actions SEPARATOR ', '»«x»«ENDFOR»
			}''');

			// Generate a derived handler that provides optional methods
			fsa.generateFile(packagePath + '/Handler.java', '''
			package «packageName»;
			
			import org.softlang.metalib.xtext.fsml.runtime.HandlerBase;
			
			public abstract class Handler implements HandlerBase<Action>
			{
				@Override
				public void handle(Action action)
				{
					if(action == null)
					{
						throw new IllegalArgumentException("null");
					}
					
					switch(action)
					{
						«FOR x : actions»
							case «x»:
								handle«x.toFirstUpper»();
								return;
						«ENDFOR»
						
						default:
						throw new IllegalArgumentException(action.toString());
					}
				}
				
				«FOR x : actions»
					protected void handle«x.toFirstUpper»()
					{
						unhandled(Action.«x»);
					}
					
				«ENDFOR»
				
				protected void unhandled(Action action)
				{
					final Class<?> c = getClass();
					
					System.out.println("Unhandled action in " + (c.isAnonymousClass() ? "anonymous class" : c.getSimpleName()) + ": " + action);
				}
			}''');

			// Generate a derived stepper
			fsa.generateFile(packagePath + '/Stepper.java', '''
			package «packageName»;
			
			import org.softlang.metalib.xtext.fsml.runtime.HandlerBase;
			import org.softlang.metalib.xtext.fsml.runtime.StepperBase;
			
			public class Stepper extends StepperBase<State, Input, Action>
			{
				public Stepper(HandlerBase<Action> handler)
				{
					this.handler = handler;
					this.state = State.«initial»;
					
					«FOR s : fsm.states»
						«FOR t : s.transitions»
							add(State.«s.name», Input.«t.input», «IF t.action != null»Action.«t.action»«ELSE»null«ENDIF», State.«t.
					destinationState.name»);
						«ENDFOR»
					«ENDFOR»
				}
			}''');

			// Generate the DGL file
			fsa.generateFile(packagePath + '.dgl', '''(
  % States
  [
  «FOR s : fsm.states SEPARATOR ',
'»	(«s.name»,«s.name»,ellipse,[«IF s.initial»filled«ENDIF»])«ENDFOR»
  ],
  % Edges
  [
  «FOR t : fsm.states.map[transitions].flatten SEPARATOR ',
'»  («t.containingState.name»,«t.destinationState.name»,[«t.graphLabel»])«ENDFOR»
  ]
).
					''');
		}
	}
}
