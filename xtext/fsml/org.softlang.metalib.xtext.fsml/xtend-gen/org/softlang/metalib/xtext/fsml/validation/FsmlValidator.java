/**
 * generated by Xtext 2.10.0
 */
package org.softlang.metalib.xtext.fsml.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.softlang.metalib.xtext.fsml.fsml.FSM;
import org.softlang.metalib.xtext.fsml.fsml.FSMState;
import org.softlang.metalib.xtext.fsml.fsml.FSMTransition;
import org.softlang.metalib.xtext.fsml.fsml.FsmlPackage;
import org.softlang.metalib.xtext.fsml.validation.AbstractFsmlValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class FsmlValidator extends AbstractFsmlValidator {
  public final static String NO_INITIAL_STATE = "noInitialState";
  
  public final static String MORE_THAN_ONE_INITIAL_STATE = "moreThanOneInitialState";
  
  public final static String EXPLICIT_NON_TRANSITION = "explicitNonTransition";
  
  public final static String NON_DETERMINISTIC = "nonDeterministic";
  
  public final static String NOT_REACHABLE = "notReachable";
  
  /**
   * Constraint check 'fsmSingleInitial'; checks if there is only one initial
   * state and marks all states if none of them is initial and marks some of
   * them if they are not exclusively initial
   */
  @Check
  public void checkHasInitialState(final FSM fsm) {
    EList<FSMState> _states = fsm.getStates();
    final Function1<FSMState, Boolean> _function = (FSMState it) -> {
      return Boolean.valueOf(it.isInitial());
    };
    Iterable<FSMState> _filter = IterableExtensions.<FSMState>filter(_states, _function);
    final int initCount = IterableExtensions.size(_filter);
    if ((initCount < 1)) {
      EList<FSMState> _states_1 = fsm.getStates();
      for (final FSMState s : _states_1) {
        this.error("FSM has no initial state", s, FsmlPackage.Literals.FSM_STATE__NAME, FsmlValidator.NO_INITIAL_STATE);
      }
    } else {
      if ((initCount > 1)) {
        EList<FSMState> _states_2 = fsm.getStates();
        final Function1<FSMState, Boolean> _function_1 = (FSMState it) -> {
          return Boolean.valueOf(it.isInitial());
        };
        Iterable<FSMState> _filter_1 = IterableExtensions.<FSMState>filter(_states_2, _function_1);
        for (final FSMState s_1 : _filter_1) {
          this.error("FSM has more than one initial state", s_1, FsmlPackage.Literals.FSM_STATE__NAME, 
            FsmlValidator.MORE_THAN_ONE_INITIAL_STATE);
        }
      }
    }
  }
  
  /**
   * This is an extraneous check that marks transition that explicitly direct to the
   * state they are in. This one is just for demonstrations purposes
   */
  @Check
  public void checkSelfTargeting(final FSMTransition transition) {
    if (((!Objects.equal(transition.getTarget(), null)) && transition.getTarget().equals(transition.eContainer()))) {
      this.warning("Transition does not change state, target should be omitted", transition, 
        FsmlPackage.Literals.FSM_TRANSITION__TARGET, FsmlValidator.EXPLICIT_NON_TRANSITION);
    }
  }
  
  /**
   * Check of the 'fsmDeterministic' constraint. This one is checked on single transitions
   * to make marking the indeterministic transitions easier
   */
  @Check
  public void checkDeterministic(final FSMTransition transition) {
    EObject _eContainer = transition.eContainer();
    final FSMState container = ((FSMState) _eContainer);
    EList<FSMTransition> _transitions = container.getTransitions();
    final Function1<FSMTransition, Boolean> _function = (FSMTransition x) -> {
      return Boolean.valueOf((Objects.equal(x.getInput(), transition.getInput()) && (!Objects.equal(x, transition))));
    };
    boolean _exists = IterableExtensions.<FSMTransition>exists(_transitions, _function);
    if (_exists) {
      this.error("Transition shares input with other transition", transition, 
        FsmlPackage.Literals.FSM_TRANSITION__INPUT, FsmlValidator.NON_DETERMINISTIC);
    }
  }
  
  /**
   * Initial call of the breadth first search
   */
  public <T extends Object> boolean findBF(final T initial, final Function1<? super T, ? extends Iterable<T>> next, final Function1<? super T, ? extends Boolean> p) {
    HashSet<T> _newHashSet = CollectionLiterals.<T>newHashSet();
    return this.<T>findBF(initial, _newHashSet, next, p);
  }
  
  /**
   * Continued call of the breadth first search; this method keeps a set of visited nodes
   */
  public <T extends Object> boolean findBF(final T initial, final Set<T> visited, final Function1<? super T, ? extends Iterable<T>> next, final Function1<? super T, ? extends Boolean> p) {
    visited.add(initial);
    Boolean _apply = p.apply(initial);
    if ((_apply).booleanValue()) {
      return true;
    } else {
      Iterable<T> _apply_1 = next.apply(initial);
      final Function1<T, Boolean> _function = (T x) -> {
        boolean _contains = visited.contains(x);
        return Boolean.valueOf((!_contains));
      };
      Iterable<T> _filter = IterableExtensions.<T>filter(_apply_1, _function);
      for (final T n : _filter) {
        boolean _findBF = this.<T>findBF(n, visited, next, p);
        if (_findBF) {
          return true;
        }
      }
      return false;
    }
  }
  
  /**
   * Returns all states that have the given state as target in any of their transitions
   */
  public Iterable<FSMState> incomingStates(final FSMState s) {
    EObject _eContainer = s.eContainer();
    final FSM fsm = ((FSM) _eContainer);
    EList<FSMState> _states = fsm.getStates();
    final Function1<FSMState, EList<FSMTransition>> _function = (FSMState it) -> {
      return it.getTransitions();
    };
    List<EList<FSMTransition>> _map = ListExtensions.<FSMState, EList<FSMTransition>>map(_states, _function);
    Iterable<FSMTransition> _flatten = Iterables.<FSMTransition>concat(_map);
    final Function1<FSMTransition, Boolean> _function_1 = (FSMTransition it) -> {
      FSMState _target = it.getTarget();
      return Boolean.valueOf(Objects.equal(_target, s));
    };
    Iterable<FSMTransition> _filter = IterableExtensions.<FSMTransition>filter(_flatten, _function_1);
    final Function1<FSMTransition, FSMState> _function_2 = (FSMTransition it) -> {
      EObject _eContainer_1 = it.eContainer();
      return ((FSMState) _eContainer_1);
    };
    return IterableExtensions.<FSMTransition, FSMState>map(_filter, _function_2);
  }
  
  /**
   * The constraint check for 'fsmReachable' checks if a state is reachable by
   * searching for the initial state with a breadth first search
   */
  @Check
  public void checkIsReachable(final FSMState state) {
    final Function1<FSMState, Iterable<FSMState>> _function = (FSMState x) -> {
      return this.incomingStates(x);
    };
    final Function1<FSMState, Boolean> _function_1 = (FSMState x) -> {
      return Boolean.valueOf(x.isInitial());
    };
    boolean _findBF = this.<FSMState>findBF(state, _function, _function_1);
    boolean _not = (!_findBF);
    if (_not) {
      this.error("State is not reachable from the initial state", state, FsmlPackage.Literals.FSM_STATE__NAME, 
        FsmlValidator.NOT_REACHABLE);
    }
  }
}
